type R = [16]
type T = [16]
type F = [32] // Fixed point
type D = [64] // Double Fixed point - used for mul and div

_T = [0 .. 22049]:[_]T

pi_sa = join [0:R, 9:R]

///// Improve these fixed point math functions
tof : R -> F
tof a = join [a, 0:R]

round : F -> R
round a = (split a : [2]R) @ 0 // Round here

trunc : F -> R
trunc a = (split a : [2]R) @ 0

fract : F -> R
fract a = (split a : [2]R) @ 1

tod : F -> D
tod a = join [0:F, a]

todd : F -> D
todd a = join [a, 0:F]

truncd : D -> F
truncd a = (split a : [2]F) @ 0

fractd : D -> F
fractd a = (split a : [2]F) @ 1

roundd : D -> F
roundd a = join [fract(truncd(a)), trunc(fractd(a))] // Round here

mul : (F, F) -> F
mul (a, b) = roundd(tod(a) * tod(b))

div : (F, F) -> F
div (a, b) = roundd(todd(a) / tod(b))

mdf : {n} (fin n) => (F, [n]R) -> F
mdf (a, b) = ys ! 0
    where ys = [a] # [ mul(div(a, tof(x)), y) | x <- b
                                               | y <- ys
                     ]

// Extremely approximate +ve sin
_sin : F -> F
_sin x = x - mdf(x, [2..3]) + mdf(x, [2..5]) - mdf(x, [2..7])

to_rad : R -> F
to_rad r = mul(tof(r), pi_sa)

to_sshort : F -> R
to_sshort f = round(mul(f, tof(0x7FFF)))
/////

///// Audio code here:
//y(t) = Asin(2pft+o)

// Used to keep t in 0 <= x < 22050 range, 1 = 2pi/22050
mma : T -> R -> R ->T 
mma t f o = t * f + o % 22050

// a = 1/A
//square_wave : R -> T -> R -> R -> R
//square_wave a t f o = 

// Use square wave here?
fix_amp : (R, R, R) -> R
fix_amp (w, a, t) = if (t >= 11025) then (w * 0xFFFF) / a else w / a

// a = 1/A
// _sin currently only "works" for 0 <= x < pi so x >= pi needs to be flipped (after rounding)
sin_wave' : R -> T -> R -> R -> R
sin_wave' a t = fix_amp(to_sshort(_sin(to_rad(t)), a, t)

sin_wave : R -> T -> R -> R -> R
sin_wave a t f o = sin_wave'(a, mma(t, f, o))

channel : T -> R
channel t = sin_wave 1 t 1 0

sample : T -> [2][8]
//sample t = join [ split (channel t) : [2][8], split (channel (t + 11025)) : [2][8] ]
sample t = split (channel t) : [2][8]

// intput to main = array of music notes? for left and right based on selecting via time
track : R -> [22050][2][8]
track f = [ sample ((f * 22049) + k) | k <- _T ]
